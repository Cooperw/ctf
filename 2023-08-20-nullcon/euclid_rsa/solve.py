#from math import gcd
from decimal import *
import math
from Crypto.Util.number import bytes_to_long, long_to_bytes

# White paper on RSA attacks w/ euclid factorization
# Reverse Engineering "3. Proposed Method" yielded good results
# https://www.mdpi.com/2297-8747/25/4/63

getcontext().prec=10000

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def simplify_fraction(numerator, denominator):
    gcd = math.gcd(numerator, denominator)
    simplified_numerator = numerator // gcd
    simplified_denominator = denominator // gcd
    return simplified_numerator, simplified_denominator

a = 
139488614271687589953884690592970545345100917058745264617112217132329766542251923634602298183777415221556922931467521901793230800271771036880075840122128322419937786441619850848876309600263298041438727684373621920233326334840988865922273325440799379584418142760239470239003470212399313033715405566836809419407
b = 
68334789534409058399709747444525414762334123566273125910569662060699644186162637240997793681284151882169786866201685085241431171760907057806355318216602175990235605823755224694383202043476486594392938995563562039702918509120988489287149220217082428193897933957628562633459049042920472531693730366503272507672
c = 
124011822519139836919119491309637022805378274989854408578991029026928119002489232335977596528581855016599610031796540079373031282148998625318658034408770283112750172223328012238338715644743140990997114236125750813379366262418292349962679006556523851370694404238101553966330965676189731474108393418372330606063
d = 
93529593432394381438671783119087013080855868893236377597950059020717371498802208966524066540234253992421963224344343067174201693672350438201011499762718490958025617655722916641293034417795512315497126128726644064013248230211347407788186320320456853993252621916838570027019607155835349111757703654306736031792
assert (a**2 + b**2) == (c**2 + d**2)
n_t = a**2 + b**2
print("n_goal")
print(n_t)

A=a-c
B=a+c
C=d-b
D=d+b

sn1, sd1 = simplify_fraction(A, C)
#print(f"{sn1}/{sd1}")

sn2, sd2 = simplify_fraction(B, C)
#print(f"{sn2}/{sd2}")

#magic_d_1 = 5*13*61 #these appear to be the factors of the upscaler, not 
sure how they pick which ones for which side
#magic_d_2 = 41

magic_d_1 = 1
magic_d_2 = 1

p = Decimal(pow(sn1, 2) + pow(sd1, 2)) / Decimal(magic_d_1)
'''
if "." in str(p):
    print("p is not an integer")
else:
    print("p is integer")
'''
print("p")
print(int(p))

q = Decimal(pow(sn2, 2) + pow(sd2, 2)) / Decimal(magic_d_2)

print("q")
print(int(q))

n = p*q
print("n")
print(int(n))
print("")

p = int(p)
q = int(q)

x = (p-1)*(q-1)
e = 65537
n = p*q
d = pow(e, -1, x)

kp = f"{n}, {e}"
ks = f"{n}, {d}"
print(f"kp\n{kp}")
print(f"ks\n{ks}")
print("")

pt = 19
print(f"RSA Test: {pt}")
ct = pow(pt, e, n)
print(f"ct\n{ct}")
pt_r = pow(ct, d, n)
print(f"pt\n{pt_r}")
print("")


# inject given ct
print(f"Reversing Flag")
ct = 
2819638499688340337879314536945338371611392232636746056275506290935131270682791584873534866138393305591899169164183372576878693678187335219904407119253951099126339949954303448641761723704171837075206394491403411400326176280981393624784437102905397888236098861970020785226848615566768625581096019917060387964269283048823007992992874533775547300443032304973521568046956516203101626941042560505073773998143068621715480774707735064134961852206070850277695448391038882766344567740211926618750074636868149063283746597347807257171871016202588384726430246523650462866812935130465049824665395626882280287488078029119879891722
print(f"ct\n{ct}")
pt_r = pow(ct, d, n)
print(f"pt\n{pt_r}")
print(long_to_bytes(pt_r))
print("")
